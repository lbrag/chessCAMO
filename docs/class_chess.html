<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>chessCAMO: Chess Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">chessCAMO
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_chess-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Chess Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class describes the chess board on which the game takes place. It contains functions which analyze specific flags to determinewhen to switch turns, display warnings, and even end the game.  
 <a href="class_chess.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="chess_8h_source.html">chess.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8b493f742d0ceced6f853fa30d3c05a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#a8b493f742d0ceced6f853fa30d3c05a8">Chess</a> ()</td></tr>
<tr class="memdesc:a8b493f742d0ceced6f853fa30d3c05a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor with default board parameter initialization - Constructs a new instance.  <a href="class_chess.html#a8b493f742d0ceced6f853fa30d3c05a8">More...</a><br /></td></tr>
<tr class="separator:a8b493f742d0ceced6f853fa30d3c05a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a930d9536191d6d6f1936b7d2c78ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#af4a930d9536191d6d6f1936b7d2c78ae">~Chess</a> ()=default</td></tr>
<tr class="memdesc:af4a930d9536191d6d6f1936b7d2c78ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the object and frees any dynamically allocated memory ('new') to avoid memory leaks.  <a href="class_chess.html#af4a930d9536191d6d6f1936b7d2c78ae">More...</a><br /></td></tr>
<tr class="separator:af4a930d9536191d6d6f1936b7d2c78ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e31b96a929e21c1502f7c11a0033ee"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#a85e31b96a929e21c1502f7c11a0033ee">Chess</a> (const <a class="el" href="class_chess.html">Chess</a> &amp;object)=default</td></tr>
<tr class="memdesc:a85e31b96a929e21c1502f7c11a0033ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor - Constructs a new instance and copies the calling object's values to it.  <a href="class_chess.html#a85e31b96a929e21c1502f7c11a0033ee">More...</a><br /></td></tr>
<tr class="separator:a85e31b96a929e21c1502f7c11a0033ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c101ca0cc850be82e59301c544dd2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_chess.html">Chess</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#a30c101ca0cc850be82e59301c544dd2f">operator=</a> (const <a class="el" href="class_chess.html">Chess</a> &amp;object)=default</td></tr>
<tr class="memdesc:a30c101ca0cc850be82e59301c544dd2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy Assignment operator - assigns values of one object to another existing object.  <a href="class_chess.html#a30c101ca0cc850be82e59301c544dd2f">More...</a><br /></td></tr>
<tr class="separator:a30c101ca0cc850be82e59301c544dd2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008d126d4430bdf95c79f935f8185c8e"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_piece.html">Piece</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#a008d126d4430bdf95c79f935f8185c8e">getBoard</a> () const</td></tr>
<tr class="memdesc:a008d126d4430bdf95c79f935f8185c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Accessor) Gets the board representation at the top of the board positions stack.  <a href="class_chess.html#a008d126d4430bdf95c79f935f8185c8e">More...</a><br /></td></tr>
<tr class="separator:a008d126d4430bdf95c79f935f8185c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2679734ba5315a4f2136bad327d23167"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#a2679734ba5315a4f2136bad327d23167">setBoard</a> (const vector&lt; <a class="el" href="class_piece.html">Piece</a> * &gt; &amp;<a class="el" href="class_chess.html#a980bd65812f24a84c25ccd46770e6a29">board</a>)</td></tr>
<tr class="memdesc:a2679734ba5315a4f2136bad327d23167"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Mutator) Updates the board representation at the top of the board positions stack.  <a href="class_chess.html#a2679734ba5315a4f2136bad327d23167">More...</a><br /></td></tr>
<tr class="separator:a2679734ba5315a4f2136bad327d23167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54753dbdf9fbfa306ea1627bc72c158"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_piece.html">Piece</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#ab54753dbdf9fbfa306ea1627bc72c158">getCheckPieces</a> () const</td></tr>
<tr class="memdesc:ab54753dbdf9fbfa306ea1627bc72c158"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Accessor) Gets the check stack information.  <a href="class_chess.html#ab54753dbdf9fbfa306ea1627bc72c158">More...</a><br /></td></tr>
<tr class="separator:ab54753dbdf9fbfa306ea1627bc72c158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768a7a389ec33b3513d223baf5948402"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#a768a7a389ec33b3513d223baf5948402">setCheckPieces</a> (vector&lt; <a class="el" href="class_piece.html">Piece</a> * &gt; <a class="el" href="class_chess.html#a154e5064761da26c3e99d6deacc6cf49">check_pieces</a>)</td></tr>
<tr class="memdesc:a768a7a389ec33b3513d223baf5948402"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Mutator) Sets the check stack information.  <a href="class_chess.html#a768a7a389ec33b3513d223baf5948402">More...</a><br /></td></tr>
<tr class="separator:a768a7a389ec33b3513d223baf5948402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfdde8cc493a35f3b407d09b8c188469"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#abfdde8cc493a35f3b407d09b8c188469">getCheck</a> () const</td></tr>
<tr class="memdesc:abfdde8cc493a35f3b407d09b8c188469"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Accessor) Gets the check information.  <a href="class_chess.html#abfdde8cc493a35f3b407d09b8c188469">More...</a><br /></td></tr>
<tr class="separator:abfdde8cc493a35f3b407d09b8c188469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1a3cceef830ccfe3a87d9922f0f134"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#a3f1a3cceef830ccfe3a87d9922f0f134">setCheck</a> (bool check)</td></tr>
<tr class="memdesc:a3f1a3cceef830ccfe3a87d9922f0f134"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Mutator) Sets the check information.  <a href="class_chess.html#a3f1a3cceef830ccfe3a87d9922f0f134">More...</a><br /></td></tr>
<tr class="separator:a3f1a3cceef830ccfe3a87d9922f0f134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d43a3774f85b8d5d11bad19c478e0b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#a0d43a3774f85b8d5d11bad19c478e0b7">getDoubleCheck</a> () const</td></tr>
<tr class="memdesc:a0d43a3774f85b8d5d11bad19c478e0b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Accessor) Gets the double check information.  <a href="class_chess.html#a0d43a3774f85b8d5d11bad19c478e0b7">More...</a><br /></td></tr>
<tr class="separator:a0d43a3774f85b8d5d11bad19c478e0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665f7ac16f6b642b99631c618216f08f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#a665f7ac16f6b642b99631c618216f08f">setDoubleCheck</a> (bool double_check)</td></tr>
<tr class="memdesc:a665f7ac16f6b642b99631c618216f08f"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Mutator) Sets the double check information.  <a href="class_chess.html#a665f7ac16f6b642b99631c618216f08f">More...</a><br /></td></tr>
<tr class="separator:a665f7ac16f6b642b99631c618216f08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5515928d7ba87c925605f6bc4f64fc11"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#a5515928d7ba87c925605f6bc4f64fc11">getCheckmate</a> () const</td></tr>
<tr class="memdesc:a5515928d7ba87c925605f6bc4f64fc11"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Accessor) Gets the checkmate information.  <a href="class_chess.html#a5515928d7ba87c925605f6bc4f64fc11">More...</a><br /></td></tr>
<tr class="separator:a5515928d7ba87c925605f6bc4f64fc11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d1c4de3670e50b7b94d0e99e34e5a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#a13d1c4de3670e50b7b94d0e99e34e5a3">setCheckmate</a> (bool checkmate)</td></tr>
<tr class="memdesc:a13d1c4de3670e50b7b94d0e99e34e5a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Mutator) Sets the checkmate information.  <a href="class_chess.html#a13d1c4de3670e50b7b94d0e99e34e5a3">More...</a><br /></td></tr>
<tr class="separator:a13d1c4de3670e50b7b94d0e99e34e5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a09e12dfa1e412d6de7a4febe1b086"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#a40a09e12dfa1e412d6de7a4febe1b086">getStalemate</a> () const</td></tr>
<tr class="memdesc:a40a09e12dfa1e412d6de7a4febe1b086"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Accessor) Gets the stalemate information.  <a href="class_chess.html#a40a09e12dfa1e412d6de7a4febe1b086">More...</a><br /></td></tr>
<tr class="separator:a40a09e12dfa1e412d6de7a4febe1b086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d0ec7ddb3558038e97b28ff5af3db6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#a89d0ec7ddb3558038e97b28ff5af3db6">setStalemate</a> (bool stalemate)</td></tr>
<tr class="memdesc:a89d0ec7ddb3558038e97b28ff5af3db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Mutator) Sets the stalemate information.  <a href="class_chess.html#a89d0ec7ddb3558038e97b28ff5af3db6">More...</a><br /></td></tr>
<tr class="separator:a89d0ec7ddb3558038e97b28ff5af3db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1422b5b3614df52ab63bfbacb4badb6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="chess_8h.html#a17ad7ce7c5310f2756f6f49d53a35f2c">pieceColor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#a1422b5b3614df52ab63bfbacb4badb6e">getTurn</a> () const</td></tr>
<tr class="memdesc:a1422b5b3614df52ab63bfbacb4badb6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Accessor) Gets the player's turn information.  <a href="class_chess.html#a1422b5b3614df52ab63bfbacb4badb6e">More...</a><br /></td></tr>
<tr class="separator:a1422b5b3614df52ab63bfbacb4badb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14266c2293dda5038b0741c7df74382"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#aa14266c2293dda5038b0741c7df74382">setTurn</a> (<a class="el" href="chess_8h.html#a17ad7ce7c5310f2756f6f49d53a35f2c">pieceColor</a> <a class="el" href="class_chess.html#a996834f05cddcc153aaca82034d2c21b">turn</a>)</td></tr>
<tr class="memdesc:aa14266c2293dda5038b0741c7df74382"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Mutator) Sets the player's turn information.  <a href="class_chess.html#aa14266c2293dda5038b0741c7df74382">More...</a><br /></td></tr>
<tr class="separator:aa14266c2293dda5038b0741c7df74382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26a49175588c8c62cc73e6db926d5de7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#a26a49175588c8c62cc73e6db926d5de7">getNumMoves</a> ()</td></tr>
<tr class="memdesc:a26a49175588c8c62cc73e6db926d5de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of moves made.  <a href="class_chess.html#a26a49175588c8c62cc73e6db926d5de7">More...</a><br /></td></tr>
<tr class="separator:a26a49175588c8c62cc73e6db926d5de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a86771533b592cf5bca840fa1a8335e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#a2a86771533b592cf5bca840fa1a8335e">setNumMoves</a> (int <a class="el" href="class_chess.html#ade396b905cebe6d95888abe8d0de7863">num_moves</a>)</td></tr>
<tr class="memdesc:a2a86771533b592cf5bca840fa1a8335e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of moves made on the board.  <a href="class_chess.html#a2a86771533b592cf5bca840fa1a8335e">More...</a><br /></td></tr>
<tr class="separator:a2a86771533b592cf5bca840fa1a8335e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64de78c01967188afa372f417a2325d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#ab64de78c01967188afa372f417a2325d">boardInit</a> ()</td></tr>
<tr class="memdesc:ab64de78c01967188afa372f417a2325d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places the pieces on the board at their correct starting positions.  <a href="class_chess.html#ab64de78c01967188afa372f417a2325d">More...</a><br /></td></tr>
<tr class="separator:ab64de78c01967188afa372f417a2325d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac149ff524cf6e5409652a6263570008a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#ac149ff524cf6e5409652a6263570008a">makeMove</a> (int src, int dest, istream &amp;in)</td></tr>
<tr class="memdesc:ac149ff524cf6e5409652a6263570008a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves a piece on the board from 'src' to 'dest' if conditions for a legal move are met.  <a href="class_chess.html#ac149ff524cf6e5409652a6263570008a">More...</a><br /></td></tr>
<tr class="separator:ac149ff524cf6e5409652a6263570008a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb419f9d3c34d47519ff38b3180747a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#aeb419f9d3c34d47519ff38b3180747a0">isCheckmate</a> (string check_type)</td></tr>
<tr class="memdesc:aeb419f9d3c34d47519ff38b3180747a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide if a move caused a checkmate according to 'check_type'.  <a href="class_chess.html#aeb419f9d3c34d47519ff38b3180747a0">More...</a><br /></td></tr>
<tr class="separator:aeb419f9d3c34d47519ff38b3180747a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98db2cbd05b743e05bca80ede848d80f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#a98db2cbd05b743e05bca80ede848d80f">isStalemate</a> ()</td></tr>
<tr class="memdesc:a98db2cbd05b743e05bca80ede848d80f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide if a move caused a stalemate.  <a href="class_chess.html#a98db2cbd05b743e05bca80ede848d80f">More...</a><br /></td></tr>
<tr class="separator:a98db2cbd05b743e05bca80ede848d80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a9e4d4b34ec9b3da12d834499515dc463"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#a9e4d4b34ec9b3da12d834499515dc463">makeMoveForType</a> (int src, int dest)</td></tr>
<tr class="memdesc:a9e4d4b34ec9b3da12d834499515dc463"><td class="mdescLeft">&#160;</td><td class="mdescRight">A move can be one of: attack, castle, en-passant, regular.  <a href="class_chess.html#a9e4d4b34ec9b3da12d834499515dc463">More...</a><br /></td></tr>
<tr class="separator:a9e4d4b34ec9b3da12d834499515dc463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbb878d6f40a142d40f1bcddbde9c91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#a5cbb878d6f40a142d40f1bcddbde9c91">pieceSwap</a> (int src, int dest, vector&lt; <a class="el" href="class_piece.html">Piece</a> * &gt; &amp;<a class="el" href="class_chess.html#a980bd65812f24a84c25ccd46770e6a29">board</a>)</td></tr>
<tr class="memdesc:a5cbb878d6f40a142d40f1bcddbde9c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used in makeMoveForType(.) to swap pieces on the board.  <a href="class_chess.html#a5cbb878d6f40a142d40f1bcddbde9c91">More...</a><br /></td></tr>
<tr class="separator:a5cbb878d6f40a142d40f1bcddbde9c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0e6941c0f1bedfad490df9649045d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#afb0e6941c0f1bedfad490df9649045d4">handleChangeTurn</a> ()</td></tr>
<tr class="memdesc:afb0e6941c0f1bedfad490df9649045d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates who will move next via a message to console.  <a href="class_chess.html#afb0e6941c0f1bedfad490df9649045d4">More...</a><br /></td></tr>
<tr class="separator:afb0e6941c0f1bedfad490df9649045d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8ebc04dfe372d1a0a84cc1f2f98a72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#a0b8ebc04dfe372d1a0a84cc1f2f98a72">handleCheckmate</a> ()</td></tr>
<tr class="memdesc:a0b8ebc04dfe372d1a0a84cc1f2f98a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates which player won by checkmate via a message to console.  <a href="class_chess.html#a0b8ebc04dfe372d1a0a84cc1f2f98a72">More...</a><br /></td></tr>
<tr class="separator:a0b8ebc04dfe372d1a0a84cc1f2f98a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d7f2a9c4cb971dbbd7803cee31dbf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#a16d7f2a9c4cb971dbbd7803cee31dbf9">handleStalemate</a> ()</td></tr>
<tr class="memdesc:a16d7f2a9c4cb971dbbd7803cee31dbf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates the game is drawn via a message to console.  <a href="class_chess.html#a16d7f2a9c4cb971dbbd7803cee31dbf9">More...</a><br /></td></tr>
<tr class="separator:a16d7f2a9c4cb971dbbd7803cee31dbf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ef4963f5dfd077c31a78112afe1f80"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#ab8ef4963f5dfd077c31a78112afe1f80">needUndoMove</a> (<a class="el" href="class_piece.html">Piece</a> *king, <a class="el" href="class_piece.html">Piece</a> *piece)</td></tr>
<tr class="memdesc:ab8ef4963f5dfd077c31a78112afe1f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">After a move is made, can undo it if move was invalid and return to previous board state.  <a href="class_chess.html#ab8ef4963f5dfd077c31a78112afe1f80">More...</a><br /></td></tr>
<tr class="separator:ab8ef4963f5dfd077c31a78112afe1f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46eb33b62b96fcc09cbc612964ba6cd1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#a46eb33b62b96fcc09cbc612964ba6cd1">singleCheckPieceIterator</a> (<a class="el" href="class_piece.html">Piece</a> *piece, <a class="el" href="class_piece.html">Piece</a> *king)</td></tr>
<tr class="memdesc:a46eb33b62b96fcc09cbc612964ba6cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">If in a single check, see if piece can defend the king, capture attacking piece, or move the king out of check. Used in isCheckmate("single")  <a href="class_chess.html#a46eb33b62b96fcc09cbc612964ba6cd1">More...</a><br /></td></tr>
<tr class="separator:a46eb33b62b96fcc09cbc612964ba6cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34695d147ce3ab81fa4826bb45e0e16"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#af34695d147ce3ab81fa4826bb45e0e16">doubleCheckPieceIterator</a> (<a class="el" href="class_piece.html">Piece</a> *king)</td></tr>
<tr class="memdesc:af34695d147ce3ab81fa4826bb45e0e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">If in a double check, see if the king can move out of check as this is the only valid move option. Used in isCheckmate("double").  <a href="class_chess.html#af34695d147ce3ab81fa4826bb45e0e16">More...</a><br /></td></tr>
<tr class="separator:af34695d147ce3ab81fa4826bb45e0e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebac8aa746ad9e6994fa0c43831f4251"><td class="memItemLeft" align="right" valign="top"><a class="el" href="chess_8h.html#a17ad7ce7c5310f2756f6f49d53a35f2c">pieceColor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#aebac8aa746ad9e6994fa0c43831f4251">switchTurn</a> ()</td></tr>
<tr class="memdesc:aebac8aa746ad9e6994fa0c43831f4251"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decides whose turn it is currently and updates the private member variable ('turn') accordingly.  <a href="class_chess.html#aebac8aa746ad9e6994fa0c43831f4251">More...</a><br /></td></tr>
<tr class="separator:aebac8aa746ad9e6994fa0c43831f4251"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a980bd65812f24a84c25ccd46770e6a29"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_piece.html">Piece</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#a980bd65812f24a84c25ccd46770e6a29">board</a></td></tr>
<tr class="separator:a980bd65812f24a84c25ccd46770e6a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154e5064761da26c3e99d6deacc6cf49"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="class_piece.html">Piece</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#a154e5064761da26c3e99d6deacc6cf49">check_pieces</a></td></tr>
<tr class="separator:a154e5064761da26c3e99d6deacc6cf49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad180d6dba047d3b236d85c537cb85be0"><td class="memItemLeft" align="right" valign="top">vector&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#ad180d6dba047d3b236d85c537cb85be0">flags</a></td></tr>
<tr class="separator:ad180d6dba047d3b236d85c537cb85be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996834f05cddcc153aaca82034d2c21b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="chess_8h.html#a17ad7ce7c5310f2756f6f49d53a35f2c">pieceColor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#a996834f05cddcc153aaca82034d2c21b">turn</a></td></tr>
<tr class="separator:a996834f05cddcc153aaca82034d2c21b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade396b905cebe6d95888abe8d0de7863"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#ade396b905cebe6d95888abe8d0de7863">num_moves</a></td></tr>
<tr class="separator:ade396b905cebe6d95888abe8d0de7863"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ad94333a56dd7f21f61ca8e3ec3c4de8d"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#ad94333a56dd7f21f61ca8e3ec3c4de8d">operator&lt;&lt;</a> (ostream &amp;out, const <a class="el" href="class_chess.html">Chess</a> &amp;chess_object)</td></tr>
<tr class="memdesc:ad94333a56dd7f21f61ca8e3ec3c4de8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overloaded extraction operator.  <a href="class_chess.html#ad94333a56dd7f21f61ca8e3ec3c4de8d">More...</a><br /></td></tr>
<tr class="separator:ad94333a56dd7f21f61ca8e3ec3c4de8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65c9944fe90cf3170728f7c4026349e"><td class="memItemLeft" align="right" valign="top">istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_chess.html#af65c9944fe90cf3170728f7c4026349e">operator&gt;&gt;</a> (istream &amp;in, <a class="el" href="class_chess.html">Chess</a> &amp;chess_object)</td></tr>
<tr class="memdesc:af65c9944fe90cf3170728f7c4026349e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overlaoded insertion operator.  <a href="class_chess.html#af65c9944fe90cf3170728f7c4026349e">More...</a><br /></td></tr>
<tr class="separator:af65c9944fe90cf3170728f7c4026349e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class describes the chess board on which the game takes place. It contains functions which analyze specific flags to determinewhen to switch turns, display warnings, and even end the game. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8b493f742d0ceced6f853fa30d3c05a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b493f742d0ceced6f853fa30d3c05a8">&#9670;&nbsp;</a></span>Chess() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Chess::Chess </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor with default board parameter initialization - Constructs a new instance. </p>
<dl class="section note"><dt>Note</dt><dd>Intentionally left blank. </dd></dl>

</div>
</div>
<a id="af4a930d9536191d6d6f1936b7d2c78ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a930d9536191d6d6f1936b7d2c78ae">&#9670;&nbsp;</a></span>~Chess()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Chess::~Chess </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the object and frees any dynamically allocated memory ('new') to avoid memory leaks. </p>
<dl class="section note"><dt>Note</dt><dd>Only <a class="el" href="class_piece.html" title="This class describes the pieces on the board at any given moment. It contains functions for determini...">Piece</a> object pointers are deleted, so this can be empty </dd></dl>

</div>
</div>
<a id="a85e31b96a929e21c1502f7c11a0033ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e31b96a929e21c1502f7c11a0033ee">&#9670;&nbsp;</a></span>Chess() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Chess::Chess </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_chess.html">Chess</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor - Constructs a new instance and copies the calling object's values to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>The object whose values will be copied</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is needed to be able to stack different board representations in the board positions stack. Otherwise, since the vector&lt;Piece*&gt; contains pointers, any updates to the position will be reflected in each layer. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a30c101ca0cc850be82e59301c544dd2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c101ca0cc850be82e59301c544dd2f">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_chess.html">Chess</a>&amp; Chess::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_chess.html">Chess</a> &amp;&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy Assignment operator - assigns values of one object to another existing object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">object</td><td>The object whose values will be copied</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting object from the assignment</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Default </dd></dl>

</div>
</div>
<a id="a008d126d4430bdf95c79f935f8185c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008d126d4430bdf95c79f935f8185c8e">&#9670;&nbsp;</a></span>getBoard()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="class_piece.html">Piece</a>*&gt; Chess::getBoard </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Accessor) Gets the board representation at the top of the board positions stack. </p>
<dl class="section return"><dt>Returns</dt><dd>The board with current piece positions in correct indicies. </dd></dl>

</div>
</div>
<a id="a2679734ba5315a4f2136bad327d23167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2679734ba5315a4f2136bad327d23167">&#9670;&nbsp;</a></span>setBoard()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Chess::setBoard </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="class_piece.html">Piece</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>board</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Mutator) Updates the board representation at the top of the board positions stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">board</td><td>The current board representation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab54753dbdf9fbfa306ea1627bc72c158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab54753dbdf9fbfa306ea1627bc72c158">&#9670;&nbsp;</a></span>getCheckPieces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="class_piece.html">Piece</a>*&gt; Chess::getCheckPieces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Accessor) Gets the check stack information. </p>
<dl class="section return"><dt>Returns</dt><dd>The check stack after any given move. </dd></dl>

</div>
</div>
<a id="a768a7a389ec33b3513d223baf5948402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a768a7a389ec33b3513d223baf5948402">&#9670;&nbsp;</a></span>setCheckPieces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Chess::setCheckPieces </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="class_piece.html">Piece</a> * &gt;&#160;</td>
          <td class="paramname"><em>check_pieces</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Mutator) Sets the check stack information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">check_pieces</td><td>The check stack which contains the board representations after each move </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfdde8cc493a35f3b407d09b8c188469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfdde8cc493a35f3b407d09b8c188469">&#9670;&nbsp;</a></span>getCheck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Chess::getCheck </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Accessor) Gets the check information. </p>
<dl class="section return"><dt>Returns</dt><dd>True if board representation has a check, False otherwise. </dd></dl>

</div>
</div>
<a id="a3f1a3cceef830ccfe3a87d9922f0f134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f1a3cceef830ccfe3a87d9922f0f134">&#9670;&nbsp;</a></span>setCheck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Chess::setCheck </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Mutator) Sets the check information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">check</td><td>The check flag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d43a3774f85b8d5d11bad19c478e0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d43a3774f85b8d5d11bad19c478e0b7">&#9670;&nbsp;</a></span>getDoubleCheck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Chess::getDoubleCheck </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Accessor) Gets the double check information. </p>
<dl class="section return"><dt>Returns</dt><dd>True if board representation has a double check, False otherwise. </dd></dl>

</div>
</div>
<a id="a665f7ac16f6b642b99631c618216f08f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a665f7ac16f6b642b99631c618216f08f">&#9670;&nbsp;</a></span>setDoubleCheck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Chess::setDoubleCheck </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>double_check</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Mutator) Sets the double check information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">double_check</td><td>The double check flag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5515928d7ba87c925605f6bc4f64fc11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5515928d7ba87c925605f6bc4f64fc11">&#9670;&nbsp;</a></span>getCheckmate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Chess::getCheckmate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Accessor) Gets the checkmate information. </p>
<dl class="section return"><dt>Returns</dt><dd>True if board representation has a checkmate, False otherwise. </dd></dl>

</div>
</div>
<a id="a13d1c4de3670e50b7b94d0e99e34e5a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13d1c4de3670e50b7b94d0e99e34e5a3">&#9670;&nbsp;</a></span>setCheckmate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Chess::setCheckmate </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checkmate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Mutator) Sets the checkmate information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">checkmate</td><td>The checkmate flag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40a09e12dfa1e412d6de7a4febe1b086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a09e12dfa1e412d6de7a4febe1b086">&#9670;&nbsp;</a></span>getStalemate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Chess::getStalemate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Accessor) Gets the stalemate information. </p>
<dl class="section return"><dt>Returns</dt><dd>True if board representation has a stalemate, False otherwise. </dd></dl>

</div>
</div>
<a id="a89d0ec7ddb3558038e97b28ff5af3db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89d0ec7ddb3558038e97b28ff5af3db6">&#9670;&nbsp;</a></span>setStalemate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Chess::setStalemate </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stalemate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Mutator) Sets the stalemate information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">stalemate</td><td>The stalemate flag </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1422b5b3614df52ab63bfbacb4badb6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1422b5b3614df52ab63bfbacb4badb6e">&#9670;&nbsp;</a></span>getTurn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="chess_8h.html#a17ad7ce7c5310f2756f6f49d53a35f2c">pieceColor</a> Chess::getTurn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Accessor) Gets the player's turn information. </p>
<dl class="section return"><dt>Returns</dt><dd>The turn at any given moment (either white's or black's). </dd></dl>

</div>
</div>
<a id="aa14266c2293dda5038b0741c7df74382"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa14266c2293dda5038b0741c7df74382">&#9670;&nbsp;</a></span>setTurn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Chess::setTurn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="chess_8h.html#a17ad7ce7c5310f2756f6f49d53a35f2c">pieceColor</a>&#160;</td>
          <td class="paramname"><em>turn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>(Mutator) Sets the player's turn information. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">turn</td><td>The turn </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26a49175588c8c62cc73e6db926d5de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26a49175588c8c62cc73e6db926d5de7">&#9670;&nbsp;</a></span>getNumMoves()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Chess::getNumMoves </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the number of moves made. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of moves. </dd></dl>

</div>
</div>
<a id="a2a86771533b592cf5bca840fa1a8335e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a86771533b592cf5bca840fa1a8335e">&#9670;&nbsp;</a></span>setNumMoves()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Chess::setNumMoves </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_moves</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the number of moves made on the board. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">num_moves</td><td>The number of moves made </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab64de78c01967188afa372f417a2325d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64de78c01967188afa372f417a2325d">&#9670;&nbsp;</a></span>boardInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chess::boardInit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places the pieces on the board at their correct starting positions. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The chess object is intialized</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Instantiates new objects corresponding to the pieces, places them in the corresponding index of the board vector and set the global object's board variable </dd></dl>

</div>
</div>
<a id="ac149ff524cf6e5409652a6263570008a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac149ff524cf6e5409652a6263570008a">&#9670;&nbsp;</a></span>makeMove()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chess::makeMove </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves a piece on the board from 'src' to 'dest' if conditions for a legal move are met. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>The source square (piece's current location) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>The destination square (piece's ending location) </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">in</td><td>input stream type (stdin or file)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The chess object is created.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>The pieces at 'src' and 'dest' positions are swapped. If needed (attacking, castling, etc.) an empty square is made. The board's state is updated to indicate that the move occured. On failure, an error message is printed and user is asked to retry. </dd></dl>

</div>
</div>
<a id="aeb419f9d3c34d47519ff38b3180747a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb419f9d3c34d47519ff38b3180747a0">&#9670;&nbsp;</a></span>isCheckmate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Chess::isCheckmate </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>check_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decide if a move caused a checkmate according to 'check_type'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">check_type</td><td>Either "single" or "double" corresponding to the check on the board</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The chess object is created.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>If board's state is in checkmate, calls <a class="el" href="class_chess.html#a0b8ebc04dfe372d1a0a84cc1f2f98a72" title="Indicates which player won by checkmate via a message to console.">handleCheckmate()</a> to print messages to console indicating the winner. Else, game continues as usual. </dd></dl>

</div>
</div>
<a id="a98db2cbd05b743e05bca80ede848d80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98db2cbd05b743e05bca80ede848d80f">&#9670;&nbsp;</a></span>isStalemate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Chess::isStalemate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decide if a move caused a stalemate. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The chess object is created.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Calls <a class="el" href="class_chess.html#a16d7f2a9c4cb971dbbd7803cee31dbf9" title="Indicates the game is drawn via a message to console.">handleStalemate()</a> to print messages to console indicating that game is drawn, if needed.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if board's state is in stalemate, else False and game continues as usual.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The chess object is created.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Calls <a class="el" href="class_chess.html#a16d7f2a9c4cb971dbbd7803cee31dbf9" title="Indicates the game is drawn via a message to console.">Chess::handleStalemate()</a> to print messages to console indicating that game is drawn, if needed.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if board's state is in stalemate, else False and game continues as usual. </dd></dl>

</div>
</div>
<a id="a9e4d4b34ec9b3da12d834499515dc463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4d4b34ec9b3da12d834499515dc463">&#9670;&nbsp;</a></span>makeMoveForType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Chess::makeMoveForType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A move can be one of: attack, castle, en-passant, regular. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>The source square of piece </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>The destination square of piece</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The chess object is created</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Swaps the pieces on the board according to 'src' and 'dest' and proper chess rules, using pieceSwap(.). If a new empty square must be created, this is handled. Returns board representation with the made move. </dd></dl>

</div>
</div>
<a id="a5cbb878d6f40a142d40f1bcddbde9c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cbb878d6f40a142d40f1bcddbde9c91">&#9670;&nbsp;</a></span>pieceSwap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Chess::pieceSwap </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="class_piece.html">Piece</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>board</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used in makeMoveForType(.) to swap pieces on the board. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>The source square of piece </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>The destination square of piece </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">board</td><td>The current board representation</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The chess object is created</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Swaps the pieces on the board according to 'src' and 'dest'. </dd></dl>

</div>
</div>
<a id="afb0e6941c0f1bedfad490df9649045d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb0e6941c0f1bedfad490df9649045d4">&#9670;&nbsp;</a></span>handleChangeTurn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Chess::handleChangeTurn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates who will move next via a message to console. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The chess object is created</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Player turn is switched, board is printed, and message is displayed if game is not over to indicate whose turn it is. </dd></dl>

</div>
</div>
<a id="a0b8ebc04dfe372d1a0a84cc1f2f98a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b8ebc04dfe372d1a0a84cc1f2f98a72">&#9670;&nbsp;</a></span>handleCheckmate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Chess::handleCheckmate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates which player won by checkmate via a message to console. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The chess object is created. A move was made (cannot checkmate in less than 2 moves in theory).</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Object's checkmate state is set to true (to end the algorithm) </dd></dl>

</div>
</div>
<a id="a16d7f2a9c4cb971dbbd7803cee31dbf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16d7f2a9c4cb971dbbd7803cee31dbf9">&#9670;&nbsp;</a></span>handleStalemate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Chess::handleStalemate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates the game is drawn via a message to console. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The chess object is created. A move was made.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>Object's stalemate state is set to true (to end the algorithm) </dd></dl>

</div>
</div>
<a id="ab8ef4963f5dfd077c31a78112afe1f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ef4963f5dfd077c31a78112afe1f80">&#9670;&nbsp;</a></span>needUndoMove()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Chess::needUndoMove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_piece.html">Piece</a> *&#160;</td>
          <td class="paramname"><em>king</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_piece.html">Piece</a> *&#160;</td>
          <td class="paramname"><em>piece</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>After a move is made, can undo it if move was invalid and return to previous board state. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">king</td><td>The king that is being attacked currently </td></tr>
    <tr><td class="paramname">piece</td><td>The piece that is attacking the king currently</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The chess object is created. A move was made.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>None</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if after move, the 'king' is still in check (single or double) or the move was invalid, output warning message and undo the move. Else, False and continue the game without undoing the move. </dd></dl>

</div>
</div>
<a id="a46eb33b62b96fcc09cbc612964ba6cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46eb33b62b96fcc09cbc612964ba6cd1">&#9670;&nbsp;</a></span>singleCheckPieceIterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Chess::singleCheckPieceIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_piece.html">Piece</a> *&#160;</td>
          <td class="paramname"><em>piece</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_piece.html">Piece</a> *&#160;</td>
          <td class="paramname"><em>king</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If in a single check, see if piece can defend the king, capture attacking piece, or move the king out of check. Used in isCheckmate("single") </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">piece</td><td>The piece that is attacking the king currently </td></tr>
    <tr><td class="paramname">king</td><td>The king that is being attacked currently</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The chess object is created. A move was made.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>None</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if no legal moves found (checkmate), else False and make the move </dd></dl>

</div>
</div>
<a id="af34695d147ce3ab81fa4826bb45e0e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34695d147ce3ab81fa4826bb45e0e16">&#9670;&nbsp;</a></span>doubleCheckPieceIterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Chess::doubleCheckPieceIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_piece.html">Piece</a> *&#160;</td>
          <td class="paramname"><em>king</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If in a double check, see if the king can move out of check as this is the only valid move option. Used in isCheckmate("double"). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">king</td><td>The king that is being attacked currently</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The chess object is created.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>None</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True if no legal moves found (checkmate), else False and make the move </dd></dl>

</div>
</div>
<a id="aebac8aa746ad9e6994fa0c43831f4251"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebac8aa746ad9e6994fa0c43831f4251">&#9670;&nbsp;</a></span>switchTurn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="chess_8h.html#a17ad7ce7c5310f2756f6f49d53a35f2c">pieceColor</a> Chess::switchTurn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decides whose turn it is currently and updates the private member variable ('turn') accordingly. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The chess object is created.</dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>None</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>'chess.turn' is set to the correct player </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ad94333a56dd7f21f61ca8e3ec3c4de8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94333a56dd7f21f61ca8e3ec3c4de8d">&#9670;&nbsp;</a></span>operator&lt;&lt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_chess.html">Chess</a> &amp;&#160;</td>
          <td class="paramname"><em>chess_object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overloaded extraction operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">out</td><td>The output type (ex. ofstream or cout) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chess_object</td><td>The chess object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream type </dd></dl>

</div>
</div>
<a id="af65c9944fe90cf3170728f7c4026349e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af65c9944fe90cf3170728f7c4026349e">&#9670;&nbsp;</a></span>operator&gt;&gt;</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">istream&amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_chess.html">Chess</a> &amp;&#160;</td>
          <td class="paramname"><em>chess_object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overlaoded insertion operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>The input type (ex. ifstream or cin) </td></tr>
    <tr><td class="paramname">chess_object</td><td>The chess object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The input stream type </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a980bd65812f24a84c25ccd46770e6a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a980bd65812f24a84c25ccd46770e6a29">&#9670;&nbsp;</a></span>board</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="class_piece.html">Piece</a>*&gt; Chess::board</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a154e5064761da26c3e99d6deacc6cf49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a154e5064761da26c3e99d6deacc6cf49">&#9670;&nbsp;</a></span>check_pieces</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="class_piece.html">Piece</a>*&gt; Chess::check_pieces</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad180d6dba047d3b236d85c537cb85be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad180d6dba047d3b236d85c537cb85be0">&#9670;&nbsp;</a></span>flags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;bool&gt; Chess::flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a996834f05cddcc153aaca82034d2c21b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a996834f05cddcc153aaca82034d2c21b">&#9670;&nbsp;</a></span>turn</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="chess_8h.html#a17ad7ce7c5310f2756f6f49d53a35f2c">pieceColor</a> Chess::turn</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ade396b905cebe6d95888abe8d0de7863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade396b905cebe6d95888abe8d0de7863">&#9670;&nbsp;</a></span>num_moves</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Chess::num_moves</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="chess_8h_source.html">chess.h</a></li>
<li>src/<a class="el" href="chess_8cpp.html">chess.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
